/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package uniproc

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.multiple
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.file
import java.io.File
import kotlin.system.exitProcess

private val VALID_TARGETS_LIST = listOf("JAVA")

class App: CliktCommand() {
    private val verbose by option("--verbose", "-v", help="Enable Verbose Logging").flag(default = false)
    private val interactive by option("--interactive", "-r", help="Start in interactive REPL mode").flag()
    private val outputPath by option("--output", "-o", help="Output File Path")
    private val targetLanguage by option("-t", "--target", help="Target compile language")
    private val source by option("-i", "--input").file()
    private val args: List<String> by option("-a", "-args").multiple()
    override fun run() {
        if (validateArgs(interactive, outputPath, targetLanguage, source)) {
            if (interactive) {
                // all we can do for now is print a demo
                val parser = Parser(verbose=verbose)
                while(!parser.myVm.exit) {
                    print("> ")
                    val line = readLine()
                    if (!line.isNullOrEmpty()) {
                        parser.executeTokens(parser.parseLine(line), args)
                    } else {
                        break
                    }
                }
            } else {
                if (outputPath == null && source != null && source!!.canRead()) {
                    val parser = Parser(verbose=verbose)
                    source!!.readLines().forEach {
                        if (parser.healthy && !parser.myVm.exit) {
                            parser.executeTokens(parser.parseLine(it), args)
                            if (parser.myVm.exit) {
                                if (verbose) {
                                    println("[DEBUG] shutting down...")
                                }
                                exitProcess(0)
                            }
                        } else {
                            println("Terminated on execution line ${parser.lineCount}")
                            exitProcess(1)
                        }
                    }
                } else if (outputPath != null && source != null && source!!.canRead()) {
                    val parser = Parser(verbose=verbose)
                    val outFile = File(outputPath!!)
                    if (!outFile.exists()) {
                        outFile.createNewFile()
                    }
                    if (outFile.canWrite()) {
                        source!!.readLines().forEach {
                            if (parser.healthy) {
                                parser.compileTokens(parser.parseLine(it))
                            } else {
                                System.err.println("An error occurred while compiling source!")
                                exitProcess(1)
                            }
                        }
                        outFile.writeText(parser.getCompiledCode(outFile.nameWithoutExtension))
                    } else {
                        System.err.println("Cannot write to file ${outFile.absoluteFile}!")
                    }
                }
            }
        }
    }

    private fun validateArgs(interactive: Boolean, outputPath: String?, targetLanguage: String?, source: File?): Boolean {
        return if (interactive && (outputPath != null || source != null)) {
            System.err.println("Cannot start in interactive mode and have an output or input file!")
            false
        } else if (targetLanguage != null && !VALID_TARGETS_LIST.contains(targetLanguage)) {
            System.err.println("$targetLanguage is not valid!")
            false
        } else if (outputPath == null && targetLanguage != null){
            System.err.println("No output file specified but cross-compile specified!")
            false
        } else if (source != null && !source.canRead()){
            System.err.println("Cannot read input file \"${source.absoluteFile}\"!")
            false
        } else {
            true
        }
    }
}

fun main(args: Array<String>) = App().main(args)
